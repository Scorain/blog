<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>babel的使用</title>
      <link href="/blog/2018/use-of-babel/"/>
      <url>/blog/2018/use-of-babel/</url>
      <content type="html"><![CDATA[<!-- build time:Fri May 18 2018 10:02:46 GMT+0800 (中国标准时间) --><p>Babel是一个编译器，用于编写下一代Javascript</p><a id="more"></a><h2 id="Babel相关的几个包"><a href="#Babel相关的几个包" class="headerlink" title="Babel相关的几个包"></a>Babel相关的几个包</h2><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p>babel-core是babel的核心包, 提供 <code>code</code>, <code>AST</code> 之间的转换能力。</p><ol><li><p>引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'babel-core'</span>;</span><br></pre></td></tr></table></figure></li><li><p>转换 <code>code</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = babel.transform(code, options);</span><br><span class="line"><span class="built_in">console</span>.dir(result); <span class="comment">// &#123;code, map, AST&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>转换 <code>file</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 异步</span></span><br><span class="line">babel.transformFile(filename, options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(result); <span class="comment">// &#123;code, map, AST&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">const</span> result = babel.transformFileSync(filename, options);</span><br><span class="line"><span class="built_in">console</span>.dir(result); <span class="comment">// &#123;code, map, AST&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>转换 <code>AST</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = babel.transformFromAst(ast, code, options);</span><br><span class="line"><span class="built_in">console</span>.dir(result); <span class="comment">// &#123;code, map, AST&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>以下为 babel 的几个转换方法中的入参和返回值</p><ul><li>参数: code 字符串，代码片段</li><li>参数: filename 字符串，文件名称，可以理解为字符流</li><li>参数: AST 对象，抽象语法树</li><li>参数: options 对象，可配置的转换参数</li><li>返回: result 对象，通常有 code AST map 三个属性，分别对应 转换后的代码片段 转换后的抽象语法树 和 转换前后的映射关系</li></ul><h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h3><p>babel-cli 将 babel-core 封装为一个命令行程序，给开发者提供在命令行中使用babel的能力。</p><p>如下为在命令行中使用babel的示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 编译文件</span><br><span class="line">babel script.js --out-file script-compiled.js</span><br><span class="line"></span><br><span class="line">// 编译目录</span><br><span class="line">babel src --out-dir lib</span><br><span class="line"></span><br><span class="line">// 简单选项：监视 映射文件 忽略文件 复制文件 忽略babelrc</span><br><span class="line">babel src --out-dir lib --watch --<span class="built_in">source</span>-maps --ignore a.js,b.js --copy-files --no-babelrc</span><br><span class="line"></span><br><span class="line">// 配置选项: 配置插件...</span><br><span class="line">babel src --out-dir lib --plugins=transform-runtime,transform-es2015-modules-amd</span><br><span class="line">babel src --out-dir lib --presets=env</span><br><span class="line">babel src --out-dir lin --name=value</span><br></pre></td></tr></table></figure><p>当配置项比较多的时候，每次执行命令时拼接大量的参数显然是不明智的，这时候我们可以将配置项放入 .babelrc 文件或者 package.json 文件中，babel 命令会自动读取文件中的信息。</p><p>如下为一个 .babelrc 文件的示例:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;<span class="attr">browsers</span>: [<span class="string">'ie &gt;= 9'</span>]&#125;,</span><br><span class="line">        modules: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如下为一个 package.json 文件的示例:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'my-package'</span>,</span><br><span class="line">  version: <span class="string">'1.0.0'</span>,</span><br><span class="line">  babel: &#123;</span><br><span class="line">    presets: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          targets: &#123;<span class="attr">browsers</span>: [<span class="string">'ie &gt;= 9'</span>]&#125;,</span><br><span class="line">          modules: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    plugins: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>babel-loader 将 babel-core 封装为一个webpack加载器，给开发者提供在webpack中使用babel的能力。</p><p>如下为在webpack中使用babel的配置示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> : &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="string">'node_modules'</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [</span><br><span class="line">            [</span><br><span class="line">              <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                targets: &#123;<span class="attr">browsers</span>: [<span class="string">'ie &gt;= 9'</span>]&#125;,</span><br><span class="line">                modules: <span class="literal">false</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          ],</span><br><span class="line">          plugins: []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h3><p>babel-preset-env 是一个 babel 插件集，供开发者快速选择所需编译能力。</p><p>可供选择的选项：</p><ul><li>targets 所需支持的运行环境，可通过 browsers 属性（利用 <a href="https://github.com/ai/browserslist" rel="external nofollow noopener noreferrer" target="_blank">browserslist</a> 规则）选择编译后所需兼容的浏览器</li><li>modules 将 esm 转换为另一种模块类型，如：amd umd systemjs commonjs false 等。默认为 commonjs；false 为不转换。</li><li>include 白名单数组</li><li>exclude 黑名单数组</li></ul><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>语言的更新换代伴随着两个类型的优化：一个是语法的优化，一个是能力的补充。</p><p>对于语法优化方面，通过AST变换可以将新旧版本对应起来；然而，新旧版本之间的能力往往是不对等的，比如新版本中一些新增的类或者属性，在旧版本中不支持。此时就需要引入一些额外的代码的打补丁。</p><p>babel-polyfill 解决的问题就是补全旧版本缺失的部分，提供一个和新版本一样的编码环境。</p><p>引入方式：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面js入口处</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">'babel-polyfill'</span>, <span class="string">'./app.js'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html中</span></span><br><span class="line">&lt;script src=<span class="string">'./dist/polyfill.js'</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="babel编译过程的理解"><a href="#babel编译过程的理解" class="headerlink" title="babel编译过程的理解"></a>babel编译过程的理解</h2><p>如果不配置插件，编译文件和源文件没有任何变化</p><p><img src="/blog/images/use-of-babel/1.png" alt=""></p><p>配置 babel-preset-env 插件集合时，源文件按照默认模块化方案 commonjs 被编译到当前主流浏览器可识别的版本</p><p><img src="/blog/images/use-of-babel/4.png" alt=""></p><p>配置 babel-preset-env 插件集合，禁用模块化方案时，源文件按照当前模块化方案被编译到当前主流浏览器可识别的版本</p><p><img src="/blog/images/use-of-babel/2.png" alt=""></p><p>配置 babel-preset-env 插件集合，并设置模块化方案为 umd ，源文件按照设置的模块化方案被编译到当前主流浏览器可识别的版本</p><p><img src="/blog/images/use-of-babel/3.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>babel的使用有 命令行，webpack集成，node脚本 等多种形式；其中命令行形式主要应用于编写组件或库，webpack集成形式主要应用于编写前端业务逻辑代码，node脚本形式没有用过暂不讨论。</p><p>babel的配置有 webpack, npm, .babelrc 等方式，具体可根据使用形式确定。</p><p>目前，babel 的配置方案一般是采用 babel-preset-env 插件集合，如果需要兼容老旧代码，最好还是禁用模块化方案，因为不禁用的话会在每个模块的开头加入严格模式声明，这可能导致页面报错。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>漫谈大前端</title>
      <link href="/blog/2018/a-glance-of-frontend/"/>
      <url>/blog/2018/a-glance-of-frontend/</url>
      <content type="html"><![CDATA[<!-- build time:Fri May 18 2018 10:02:46 GMT+0800 (中国标准时间) --><p>本文是一篇分享记录，虽以大前端为题，内容并不局限于前端的范畴，确切的说，算是对当前js(ECMAScript)能力的概括。</p><a id="more"></a><p>下图为本文主要结构，原始分享PPT可<a href="https://prezi.com/p/rs70y0ozmnnk/" rel="external nofollow noopener noreferrer" target="_blank">点击此处查看</a></p><p><img src="/blog/images/a-glance-of-frontend/1.png" alt=""></p><p>分享往往从历史故事开始。<br>1995年，javascript诞生；1998年左右，ajax得到应用；2006年，jQuery第一个版本面世；2009年，nodejs &amp; angular.js；再后来，HTML5,CSS3…</p><p>最初，js被设计用于网页表单验证，随着互联网的发展，跑在浏览器上的页面承载了越来越多的功能，为了满足各种需求，js不得不不断的进化，变得越来越完善；不满于被浏览器所限制，Nodejs使得其脱离了浏览器的桎梏，从此蛟龙入海，大显神威。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web应用采用B/S结构，寄生于浏览器中，有浏览器和服务器两个端，分别对应于前端和后端。</p><h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p>作为浏览器中能够运行的唯一一种脚本语言，js当然显得有恃无恐。以浏览器提供的API(BOM,DOM)作为土壤，一个个js脚本文件辛勤地耕作着…</p><p>用户总是喜新厌旧的，每天对着千篇一律的页面，难免会失去兴致，所以，是时候加一点佐料了。</p><p>现代浏览器开放了许多先进的新特性，用于补充网页的能力，使得js可以操作更加接近底层的系统与硬件，如：</p><ol><li>用于本地存储数据的 localStorage,sessionStorage</li><li>用于开启辅助线程的 Web Worker</li><li>用于消息推送的 notification</li><li>用于绘制图像的 canvas,WebGl</li></ol><p>等等等…</p><h4 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h4><p>对于只能运行在浏览器上这一点，js肯定是心有不甘的，就像一个叛逆的少年，离家出走的想法不止一次的出现在脑海里，终于有一天，远走，去了他乡。当然，离开意味着成长。</p><p>Nodejs是一种基于V8引擎的js运行环境，提供了许多模块。其中：fs模块，使得js拥有了操作文件的能力；http模块，使得js拥有了编写后端逻辑的能力…</p><p>Nodejs有如下特性：异步，事件驱动，非阻塞I/O<br>基于这些特性，产生了如下优点：高并发，适合I/O密集型应用<br>然而，Nodejs并不是银弹，也是有些缺点的，比如：不适合CPU密集型应用<br>目前，Nodejs主要应用于如下场景：Web应用接入层，RESTful API，前端构建</p><p>点此查看<a href="http://nodejs.cn/" rel="external nofollow noopener noreferrer" target="_blank">Nodejs官方介绍</a></p><h2 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h2><p>随着智能手机的普及，移动端应用几乎成为每个互联网产品的标配。移动应用可以分为如下三种类型：原生应用(native app)， 网页应用(web app)，混合应用(hybrid app)。</p><h4 id="Hybird"><a href="#Hybird" class="headerlink" title="Hybird"></a>Hybird</h4><p>混合应用是基于webview的，native的webview控件将native外壳与web内容组合起来,形成了混合模式的移动应用。此类应用平衡了native与web之间的优缺点，目前比较流行。</p><p>优点：跨平台、多种设备兼容、升级快速和维护方便<br>缺点：交互体验和性能都会比native app差一点<br>与native app之间的通讯：JSBridge,JSPatch</p><p>具体可参看<a href="https://zhuanlan.zhihu.com/p/21387961" rel="external nofollow noopener noreferrer" target="_blank">浅谈 Hybrid App</a></p><h4 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h4><p>一份代码，同时编译成不同安装包(Android,Ios)，然后提交到对应的应用市场，供用户下载，安装和使用。</p><p>相关技术：NativeScript, React Native, Weex</p><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p>作为下一代web应用模型，pwa旨在突破 web 平台本身对 web 应用固有的桎梏：客户端软件（即网页）需要下载所带来的网络延迟，与 Web 应用依赖浏览器作为入口所带来的体验问题。</p><p>相关技术背景：Web App Manifest, Service Worker, Push Notification。</p><p>可参看<a href="https://zhuanlan.zhihu.com/p/25167289" rel="external nofollow noopener noreferrer" target="_blank">下一代 Web 应用模型 — Progressive Web App</a></p><h2 id="Desktop-amp-OS"><a href="#Desktop-amp-OS" class="headerlink" title="Desktop &amp; OS"></a>Desktop &amp; OS</h2><p>在桌面端，js的能力已经纵深到桌面应用甚至是桌面系统。</p><h4 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h4><p>Electron 是一个使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用的框架</p><p>目前 Electron 官网上已经列出了将近500个左右的应用，详细可查看<a href="https://electronjs.org/apps" rel="external nofollow noopener noreferrer" target="_blank">Electron官网应用</a></p><h4 id="chrome-os"><a href="#chrome-os" class="headerlink" title="chrome os"></a>chrome os</h4><p>Chrome OS是一款Google开发的基于PC的操作系统。<br><a href="https://www.bilibili.com/video/av279438/" rel="external nofollow noopener noreferrer" target="_blank">Chrome OS演示</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>那么，js还能做些什么呢？？？<br>游戏：Unity5, cocos<br>插件：sketch, photoshop, greasemonkey<br>硬件：cylon<br>或许更多…</p><p><strong>EOF</strong></p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【译】CSS Grid重构Medium的文章布局</title>
      <link href="/blog/2018/recreate-medium-article-layout-with-grid/"/>
      <url>/blog/2018/recreate-medium-article-layout-with-grid/</url>
      <content type="html"><![CDATA[<!-- build time:Fri May 18 2018 10:02:46 GMT+0800 (中国标准时间) --><p>当人们想起CSS Grid的时候，想到的通常是图片网格布局和全屏页面。然而，CSS Grid事实上也是一项很适用于文章布局的技术，它可以做一些以前很难完成的事情。</p><p>在本教程中，我将阐述怎样用CSS Grid去重构著名站点Medium的文章布局。</p><a id="more"></a><p>此文灵感来自于Scrimba上的免费CSS Grid教程。<a href="https://scrimba.com/g/gR8PTE" rel="external nofollow noopener noreferrer" target="_blank">点此查看</a></p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/1.png" alt="点击此图获取全部CSS Grid课程"></p><p>在<a href="https://scrimba.com/p/pWqLHa/cdp76sD" rel="external nofollow noopener noreferrer" target="_blank">本课程中的一个录屏</a>中，我的同事<a href="https://medium.com/@judofyr" rel="external nofollow noopener noreferrer" target="_blank">Magnus Holm</a>阐述了怎样将CSS Grid用于文章布局。</p><h2 id="内容部分"><a href="#内容部分" class="headerlink" title="内容部分"></a>内容部分</h2><p>我们将从一个基本的HTML文件开始，包含Medium上文章的典型内容类型。例如：标题、段落、子标题、图片、引用等等。如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Running any NPM package in the browser locally<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>JavaScript has never had any official solution for distributing packages, and every web platform (Rails, Django etc) has their own idea of how to structure and package JavaScript. In the last few years NPM has started becoming the canonical way of distribution, with Webpack as the build system, but there’s no way to load NPM packages in the browser without a server-side component.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Scrimba is a platform for interactive coding screencast where</span><br><span class="line">you can run the code at any moment in time.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://mave.me/img/projects/full_placeholder.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你不调整任何布局直接在浏览器中打开此文件，你看到的是这样子的：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/2.png" alt=""></p><p>一点也不美观。因此让我们一起用CSS Grid来调整一下吧。为了让大家都能跟得上，我们将一步一步来完成。</p><h2 id="基本margins设置"><a href="#基本margins设置" class="headerlink" title="基本margins设置"></a>基本margins设置</h2><p>我们要做的第一件事是将整个<code>&lt;article&gt;</code>标签变成一个grid容器，并设置至少三列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">740px</span> <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一列和最后一列充当边缘部分并且自适应，它们大部分情况下包含着空白区域。中间一列固定为740px，将容纳文章的主体内容。</p><p>注意，我们没有定义行是因为每一行的高度都是由它们的自身内容所决定。文章中的每块内容（段落、图片、标题）自成一行。</p><p>下一步是确保网格中的所有内容默认开始于第二条纵向网格线。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &gt; * &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们得到如下结果：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/3.png" alt=""></p><p>我们立刻就发现它变得稍微好看一点了，因为两边的空白区域让文本更易于阅读了。</p><p>然而，将左右<code>margin</code>属性设置为<code>auto</code>也能实现这种效果，而且更简单。我们为什么要用CSS Grid呢？</p><p>好了，当我们想要模仿Medium上的图片的某些特性的时候，问题出现了。例如插入一张全屏宽的图片，像下面这样：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/4.jpg" alt=""></p><p>如果我们之前用了<code>margin: 0 auto</code>, 我们将只能利用负边距（margins）来使得图片占据全屏宽度，这种方法显得很hack。</p><p>使用CSS Grid的话，可以很轻易的解决这个问题，我们只需要简单的用列来设置宽度。为了确保图片占据整个宽度，我们只需要将其跨度设置为从第一列到最后一列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">figure</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span> / -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再设置一下上下边距，就得到了一幅漂亮的全屏宽的图片：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/5.png" alt=""></p><h2 id="多列使用扩展"><a href="#多列使用扩展" class="headerlink" title="多列使用扩展"></a>多列使用扩展</h2><p>然而，这并没有为我们解决所有的问题，Medium上还有一些其他类型的布局需要我们考虑。我们一起来看几个：</p><h3 id="中型尺寸图片"><a href="#中型尺寸图片" class="headerlink" title="中型尺寸图片"></a>中型尺寸图片</h3><p>这是一种介于常规图片和全屏宽图片之间的图片，我们称之为中型尺寸图片。如下所示：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/6.jpg" alt="提示：在移动端，此类图片和全屏宽图片表现一致。本文中，我们只关注桌面端布局"></p><p>这将需要在我们现有的布局中至少新增两列。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>另外，在Medium上，如果你添加一条引用，文章的左侧也会出现一条垂直线</p><p style="border-left:3px solid rgba(0,0,0,.84);padding-left:20px;margin-left:-23px">← 注意这条垂直线，我们需要在我们的网格上额外新增一列来实现它。</p><p>这需要在网格的左侧有一个小型的列，为了对称，我们将在右侧也加一个相同的列。</p><p>因此，为了支持 <strong>引用</strong> 和 <strong>中间尺寸图片</strong>，我们需要将容器宽度划分为7列而不是三列，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">10px</span> <span class="number">740px</span> <span class="number">10px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用 Chrome 检查器，我们可以显式地看到背后的网格线（如下图所示），此外，我还增加了一些箭头来标识出不同的列，以便于识别。</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/7.png" alt=""></p><p style="text-align:center"><em>我增加了箭头用于更好地识别不同列</em></p><p>接下来，我们要做的第一件事是让所有的默认子项从第四条纵向网格线开始，而不是之前的第二条。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &gt; * &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以通过设置如下样式来创建中间尺寸图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">figure</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / -<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Chrome 检查器下展示如下这样：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/8.png" alt=""></p><p>通过设置如下样式可以轻松创建引用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span> / <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置它的纵向跨度为从第三条网格线到第五条网格线。同时增加10px的左边距 <code>padding-left: 10px</code> 使得文本看起来像是从第四条网格线开始(第三列也是10px宽)。如下是在网格上的展示：</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/9.png" alt=""></p><h3 id="侧面标记"><a href="#侧面标记" class="headerlink" title="侧面标记"></a>侧面标记</h3><p>现在还有最后一种类型需要支持。Medium上有一个非常好的标明文章中突出内容的方式。文本变绿，并在右上角产生一个高亮标记。</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/10.png" alt=""></p><p>如果我们之前用的是 <code>margin: 0 auto</code> 而不是 CSS Grid的话，由于与文章中的其他元素的表现都不一样，右上角高亮标记文本元素的创建将会很麻烦。我们期望它出现在上一个元素的右侧而不是重起一行。如果我们没有使用CSS Grid，我们可能不得不用大量的 <code>position: absolute</code> 来实现这种效果。</p><p>使用 CSS Grid 就变得超级简单了。我们只需要设置这种元素从第五条网格线开始。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会自动将其置于文章的右侧。</p><p><img src="/blog/images/recreate-medium-article-layout-with-grid/11.png" alt=""></p><p>就这样，现在我们已经用 CSS Grid 重构了Medium上文章布局的绝大部分，这实际上很简单。但请注意，我们还没有涉及到响应式，这部分需要重新写一篇文章。</p><p><a href="https://scrimba.com/c/cedLJfW" rel="external nofollow noopener noreferrer" target="_blank">Scrimba上查看所有代码</a></p><p>原文：<a href="https://medium.freecodecamp.org/how-to-recreate-mediums-article-layout-with-css-grid-b4608792bad1" rel="external nofollow noopener noreferrer" target="_blank">How to recreate Medium’s article layout with CSS Grid</a></p><p>作者：<a href="https://medium.freecodecamp.org/@perborgen" rel="external nofollow noopener noreferrer" target="_blank">Per Harald Borgen</a></p><p><strong>EOF</strong></p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
